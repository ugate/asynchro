<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>asynchro - documentation</title>

  <script src="scripts/prettify/prettify.js"></script>
  <script src="scripts/prettify/lang-css.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  <style>
  #topNav {
    width: 100%;
    height: 64px;
    padding: 16px;
    font-size: 32px;
    margin-left: 250px;
    background-color: #E0E0E0;
  }
  @media only screen and (max-width: 680px) and (min-width: 320px) {
    #topNav {
      margin-left: 0px;
    }
  }
  #topNav a {
    text-decoration: none;
  }
  #topNav .sep {
    padding: 16px;
  }
  </style>
  <script>
    window.addEventListener('load', function(event) {
      var readme = document.querySelector('.readme > article > h1');
      if (readme) readme.parentElement.removeChild(readme);
    });
  </script>
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
  <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Tutorials</li><li class="nav-item"><a href="tutorial-1-started.html">Getting Started</a></li><li class="nav-item"><a href="tutorial-2-queue.html">The Queue</a></li><li class="nav-item"><a href="tutorial-3-verification.html">Verification</a></li><li class="nav-item"><a href="tutorial-4-branches.html">Branching</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Asynchro.html">Asynchro</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Asynchro.html#.asyncCallback">asyncCallback</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Asynchro.html#.extractFuncArgs">extractFuncArgs</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Asynchro.html#.promisifyEvents">promisifyEvents</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Asynchro.html#background">background</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Asynchro.html#backgroundWaiter">backgroundWaiter</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Asynchro.html#messages">messages</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Asynchro.html#parallel">parallel</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Asynchro.html#parallelThrowOverride">parallelThrowOverride</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Asynchro.html#resultArg">resultArg</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Asynchro.html#run">run</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Asynchro.html#series">series</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Asynchro.html#seriesThrowOverride">seriesThrowOverride</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Asynchro.html#throwsError">throwsError</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Asynchro.html#verify">verify</a></span></li>
</nav>

<div id="topNav">
  <a href="index.html" id="source" title="Source Code">
    &#8669; asynchro
  </a>
  <span class="sep">|</span>
  <a href="https://github.com/ugate/asynchro#readme" id="source" title="Source Code">
    <img height="24" width="24" src="img/github.svg" />
  </a>
</div>

<div id="main">
  <section>

<header>
    
</header>

<article>
    <h3>The Queue</h3><p>At the heart of <code>asynchro</code> is a queue. The queue is simply an <code>Object[]</code> that holds function execution metadata until <a href="Asynchro.html#run">Asynchro.run</a> is executed/ran. A single <em>result</em> object can be passed to the <code>Asynchro</code> constructor in order to store the results from each queued async function execution using a designated <em>name</em> as the property name in the <em>result</em> object (more on this later!). Each queued async function is ran in the order that it was queued. Although there are variations of each, there are only three types of async functions that can be queued:</p>
<ol>
<li><a href="Asynchro.html#series">Series</a> - async functions that are <code>await</code>ed for until the next async function in the queue is invoked</li>
<li><a href="Asynchro.html#parallel">Parallel</a> - async functions that are <em>not</em> immediately <code>await</code>ed for, but rather <code>await</code>ed for after the queue is exhausted</li>
<li><a href="Asynchro.html#background">Background</a> - like, parallel, but will <em>not</em> be <code>await</code>ed for and will still retain error handling set on the queued function (or error handling defined globally on the <code>Asynchro</code> instance itself)</li>
</ol>
<p>Let's review the simple workflow below:</p>
<pre class="prettyprint source lang-js"><code>  const ax = new Asynchro({}, false, console.log);
  ax.series('one', mySeriesFunc1, 'val1', 2, 3);
  ax.series('two', mySeriesFunc2, 1, 2);
  ax.parallel('three', myParallelFunc1, { a: 1, b: 2, c: 3 });
  ax.parallel('four', myParallelFunc2);
  ax.parallelThrowOverride('five', true, myParallelFunc3, 'always throw errors');
  ax.series('six', mySeriesFunc3, true, false);
  const result = await ax.run();
  return { result, errors: ax.errors };</code></pre><p>The <code>Asynchro</code> constructor is called by passing a <em>result</em> object as it's 1<sup>st</sup> argument where all of the results of each queued async function will be stored. For instance, the final results returned from <a href="Asynchro.html#run">Asynchro.run</a> (or accessed by <a href="Asynchro.html#result">Asynchro.result</a>) would consist of the following <strong>assuming no errors are thrown</strong>:</p>
<pre class="prettyprint source lang-js"><code>// Asynchro.result
{
  one: 'return string from mySeriesFunc1',
  two: { myString: 'mySeriesFunc2 returned an object' }
  three: 'results can be anything',
  four: '...another result',
  five: true,
  six: 123
}</code></pre><p>Each argument passed after the async function will be passed in order to that function. For example, <code>mySeriesFunc1</code>/&quot;one&quot; would receive <code>val1</code>, <code>2</code>, <code>3</code>.
To omit an async function's return value from the final result simply use <code>null</code>, <code>false</code> or <code>undefined</code> as the <em>name</em> argument value: <code>ax.series(null, mySeriesFunc1, 'val1', 2, 3);</code>.</p>
<h4>Passing Results During Execution</h4><p>Passing results from one async function to the next is fairly easy to follow using <a href="Asynchro.html#resultArg">Asynchro.resultArg</a>:</p>
<pre class="prettyprint source lang-js"><code>const ax = new Asynchro({});
ax.series('one', async () => {
  // other async operations here
  return { array: [1] };
});
ax.series('two', async (array) => {
  // other async operations here
  const rtn = 2;
  array.push(rtn);
  return rtn;
}, ax.resultArg('one.array'));
ax.series('three', async (a1) => {
  // other async operations here
  console.log(a1); // prints out 1
  return a1 + 2;
}, ax.resultArg('one.array[0]'));
ax.series(null, async (array) => {
  // other async operations here
  array.push(4);
}, ax.resultArg('one.array'));
const rslt = await ax.run();
console.log(rslt); // { one: { array: [1, 2, 4] }, two: 2, three: 3 }</code></pre><p>Keep in mind that result arguments may not be available in a <em>parallel</em> async function when coming from a previously queued <em>parallel</em> async function execution (depending on how long the previous operation takes):</p>
<pre class="prettyprint source lang-js"><code>const ax = new Asynchro({});
ax.parallel('one', async () => {
  // other async operations here
  return { array: [1] };
});
ax.parallel(null, async (array) => {
  // other async operations here
  array.push(2); // ERROR: one.array not yet set!
}, ax.resultArg('one.array'));</code></pre><h4>Error Handling</h4><p>You may have noticed that the 2<sup>nd</sup> argument passed into the <code>Asynchro</code> constructor was explicitly set to <code>false</code> (which is the default value). So, no errors will be thrown but rather captured in an <code>Error[]</code> via <a href="Asynchro.html#errors">Asynchro.errors</a> unless explicitly overridden by using <a href="Asynchro.html#seriesThrowOverride">Asynchro.seriesThrowOverride</a> or <a href="Asynchro.html#parallelThrowOverride">Asynchro.parallelThrowOverride</a> as seen in example for <code>myParallelFunc3</code>/&quot;five&quot; where <code>true</code> was used. This is referred to as an <strong>Error Handling Rule</strong>. Now let's assume that there was an error while <code>await</code>ing <code>mySeriesFunc2</code>/&quot;two&quot;. The queue would <code>catch</code>/capture the error and <em>continue</em> to execute subsequent async functions in the queue. Each error will contain additional <em>metadata</em> under an <code>Asynchro</code> property that will provide more details about the error:</p>
<pre class="prettyprint source lang-js"><code>// Asynchro.result
{
  one: 'return string from mySeriesFunc1',
  three: 'results can be anything',
  four: '...another result',
  five: true,
  six: 123
}
// Asynchro.errors
[
  { // the error object
    // ... other error properties here
    Asynchro: {
      name: 'two',
      operation: 'mySeriesFunc2',
      isPending: false,
      isParallel: false,
      isBackground: false
    }
  }
]</code></pre><p>Assuming that the <strong>Error Handling Rule</strong> was set to <code>true</code>, the same error would have been thrown and would have contained the same <code>Asynchro</code> metadata. But what if we only want to throw specific errors- like &quot;system&quot; errors? <code>Asynchro</code> provides a way to define what errors are thrown and what errors are caught/captured by using an <code>Object</code> descriptor as the <strong>Error Handling Rule</strong> instead of the <code>Boolean</code> values previously discussed.
To <em>throw</em> only &quot;system&quot; errors defined by <a href="Asynchro.html#systemErrorTypes">Asynchro.systemErrorTypes</a>, the <strong>Error Handling Rule</strong> can be set to the following <code>Object</code> descriptor:</p>
<pre class="prettyprint source lang-js"><code>{
  invert: false, // true to catch errors when matches are made, false/omit to throw errors when matches are made
  matches: 'system' // only errors that are an instanceof the predefined &quot;system&quot; error classes will be thrown 
}</code></pre><p>To <em>throw</em> all errors, but &quot;system&quot; errors defined by <a href="Asynchro.html#systemErrorTypes">Asynchro.systemErrorTypes</a>, set <code>invert = true</code>. Also, <code>matches</code> can be set to an <code>Array</code> of types/classes that will be used when checking if the <code>Error</code> is an <code>instanceof</code> any one of the defined entries:</p>
<pre class="prettyprint source lang-js"><code>{
  matches: [ RangeError, MyCustomError ] // only errors that are an instanceof RangeError or MyCustomError will be thrown 
}</code></pre><p>Another way to control which errors are caught or thrown is to use an <code>Object</code> as the <code>matches</code> value. Any error that contains <em>all</em> of the properties/values defined on that <code>Object</code> will be thrown (or alternatively caught when <code>invert = true</code>):</p>
<pre class="prettyprint source lang-js"><code>{
  matches: { // only errors that contain someProperty1 = true and someProperty2 = false will be thrown
    someProperty1: true,
    someProperty2: false
  } 
}</code></pre><p>For convenience, <a href="Asynchro.html#throwsError">Asynchro.throwsError</a> is provided to check if the queue will throw or catch a specified <code>Error</code>/error type.</p>
<h4>Callback Conversions</h4><p>Most <em>callback</em> style functions that follow the <code>function(error, function callback(error, returnValue))</code> schematics can be converted/promisified into an async function using a utility such as the one provided by <code>util.promisify</code> in <a href="https://nodejs.org">Node.js</a>. But if you're running in a browser or just need to be able to wrap/<em>promisify</em> a synchronous function with a callback function that contains multiple arguments with an asynchronous one, <code>asynchro</code> provides some simple solutions to assist. <a href="Asynchro.html#asyncCallback">Asynchro.asyncCallback</a> does the conversion provided that the callback function belongs to an <code>Object</code>:</p>
<pre class="prettyprint source lang-js"><code>const myCallbackObj = { // could also be a class instance
  multiply: (a, b, c, cb) => {
    const thiz = this;
    setTimeout(() => {
      cb(thiz.error, 10 * (a || 0), 20 * (b || 0), 30 * (c || 0), cb);
    }, 500);
  }
};
const myAsyncFunc = Asynchro.asyncCallback(myCallbackObj, 'multiply');
const myAsyncFuncNamed = Asynchro.asyncCallback(myCallbackObj, 'multiply', [ 'a', 'b', 'c' ]);
(async () => {
  var rslt;
  rslt = await myAsyncFunc(0, 1, 2); // 10 * 0 = 0, 20 * 1 = 20, 30 * 2 = 60
  console.log(rslt); // [ 0, 20, 60 ]
  rslt = await myAsyncFuncNamed(1, 2, 4); // 10 * 1 = 10, 20 * 2 = 40, 30 * 4 = 120
  console.log(rslt); // { a: 10, b: 40, c: 120 }
  rslt = await myAsyncFuncNamed(2, 4, 6); // 10 * 2 = 20, 20 * 4 = 80, 30 * 6 = 180
  console.log(rslt); // { a: 20, b: 80, c: 180 }

  myCallbackObj.error = new Error('My expected error');
  try {
    rslt = await myAsyncFunc(0, 1, 2);
  } catch (err) {
    console.log(err); // My expected error
  }
})();</code></pre><p>Which enables the converted function to be added to the queue:</p>
<pre class="prettyprint source lang-js"><code>const myAsyncFunc = Asynchro.asyncCallback(myCallbackObj, 'multiply', [ 'a', 'b', 'c' ]);
const ax = new Asynchro({}, false, console.log);
ax.series('one', myAsyncFunc, 1, 2, 4);
// ...more async function added to the queue here
const rslt = await ax.run();
console.log(rslt); // { one: { a: 10, b: 40, c: 120 } }</code></pre><h4>Event Conversions</h4><p>On some occasions there may be certain events that need to be <code>await</code>ed for before continuing queue execution. In order to achieve this <code>asynchro</code> provides <a href="Asynchro.html#promisifyEvents">Asynchro.promisifyEvents</a>.</p>
<pre class="prettyprint source lang-js"><code>const rslt = await Asynchro.promisifyEvents(eventObject, ['my-event'], 60000); // if no event is fired within 60 secods a timeout error is thrown</code></pre><h4><a href="tutorial-3-verification.html">Verification &gt;&gt;</a></h4>
</article>

</section>

</div>

<br class="clear">

<footer>
  <b>asynchro v1.0.0</b><br/>
  Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Sep 27 2018 16:56:12 GMT-0400 (Eastern Daylight Time).
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>